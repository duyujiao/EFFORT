# 线程

## 线程的概述

线程是轻量级的进程，在 Linux环境下线程的本质仍是进程。在计算机上运行的程序是一组指令及指令参数的组合，指令按照既定的逻辑控制计算机运行。操作系统会以进程为单位，分配系统资源，可以这样理解，<font color=red>进程是资源分配的最小单位，线程是操作系统调度执行的最小单位。</font>

线程和进程之间的区别：

线程更加节省系统资源，多个线程共用同一个地址空间。

多个线程独享的是：自己的栈区，寄存器（内核中管理）

共享的是：代码段，堆区，全局数据区，打开的文件（文件描述符）

线程是程序的最小执行单位，进程是操作系统中的最小的资源分配单位。

一个进程对应一个虚拟的地址空间，一个进程只能抢一个cpu时间片

一个地址空间可以划分出多个线程，在有效的资源基础上，能够抢更多的cpu时间片

## 创建线程

每个线程对应一个唯一的线程ID，ID的类型为pthread_t,无符号长整形

```c
pthread_t pthread_self(void)//返回当前进程的ID
```

```c
#include<pthread.h>
int pthread_create(pthread_t*thread,const pthread_attr_t*attr,void*(*start_routine)(void*),void*arg)
    //thread：传出参数，是无符号长整形数，线程创建成功，会将线程ID写入这个指针指向的内存中
    //attr：线程的属性，一般情况下使用默认属性即可，写NULL
    //start_routine：函数指针，创建出的子线程的处理动作，也就是该函数在子线程中运行
    //arg：作为实参传递到start_routine指针指向的函数内部
    //返回值：线程 创建成功返回0,创建失败返回对应的错误号
    //返回值类型为void*类型，参数是后面的void*类型，可以把任意类型的arg类型传递给回调函数
```

```c
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<string.h>
#include<pthread.h>

void* callback(void*arg)
{
	for(int i=0;i<5;i++)
	{
		printf("子线程:i=%d\n",i);
	}
	printf("子线程:%ld\n",pthread_self());
	return NULL;
}
int main()
{
	pthread_t tid;
	pthread_create(&tid,NULL,callback,NULL);
	for(int i=0;i<5;i++)
	{
		printf("主线程:i=%d\n",i);
	}
	printf("主线程:%ld\n",pthread_self());
    //sleep(3);//主线程执行完毕后就会释放对应的地址空间，所以让子线程执行完毕主线程再退出
	pthread_exit(NULL);//线程退出
    return 0;
}


//输出：
/*主线程:i=0
主线程:i=1
主线程:i=2
主线程:i=3
主线程:i=4
主线程:139883889375040
子线程:i=0
子线程:i=1
子线程:i=2
子线程:i=3
子线程:i=4
子线程:139883886671424*/

```

## 线程回收

```c
#include<pthread.h>
//这是一个阻塞函数，子线程在运行这个函数就阻塞
//子线程退出，函数解除阻塞，回收对应的子线程资源，类似于回收进程使用的函数wait()
int pthread_join(pthread_t thread,void **retval);
//thread:要被回收的子线程的线程ID
//retval:二级指针，指向一级指针的地址，是一个传出参数，这个地址存储了pthread_exit()传递出的数据，如果不需要这个参数，可以指定为NULL
//返回值：线程回收成功返回0,回收失败返回错误号，保存了传出来的地址
```

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <pthread.h>

struct Test
{
	int num;
	int age;
};
struct Test t;
void *callback(void *arg)
{
	for (int i = 0; i < 5; i++)
	{
		printf("子线程:i=%d\n", i);
	}
	//把它定义在外面，就是一个全局变量
	t.num = 10;
	t.age = 9;
	pthread_exit(&t);//栈区内存释放,访问不到，所以要定义一个全局变量
	printf("子线程:%ld\n", pthread_self());
	return NULL;
}
int main()
{
	pthread_t tid;
	pthread_create(&tid, NULL, callback, NULL);
	for (int i = 0; i < 5; i++)
	{
		printf("主线程:i=%d\n", i);
	}
	printf("主线程:%ld\n", pthread_self());
	void *ptr; // ptr指向&t
	pthread_join(tid, &ptr);
	struct Test *pt = (struct Test *)ptr;
	printf("num=%d,age=%d\n", pt->num, pt->age);
	// pthread_join(tid,NULL);不接受子线程传出来的数据
	return 0;
}

/*
使用子线程的栈：
主线程:i=0
主线程:i=1
主线程:i=2
主线程:i=3
主线程:i=4
主线程:140355027339072
子线程:i=0
子线程:i=1
子线程:i=2
子线程:i=3
子线程:i=4
num=0,age=0这里num和age是随机数*/

/*解决方案一：使用全局变量
主线程:i=0
主线程:i=1
主线程:i=2
主线程:i=3
主线程:i=4
主线程:139814649661248
子线程:i=0
子线程:i=1
子线程:i=2
子线程:i=3
子线程:i=4
num=10,age=9*/

/*解决方案二：使用主线程的栈空间*/
struct Test
{
	int num;
	int age;
};

void *callback(void *arg)
{
	for (int i = 0; i < 5; i++)
	{
		printf("子线程:i=%d\n", i);
	}
	struct Test *t = (struct Test *)arg;
	// 把它定义在外面，就是一个全局变量
	t->num = 10;
	t->age = 9;
	pthread_exit(t); // 栈区内存释放,访问不到，所以要定义一个全局变量
	printf("子线程:%ld\n", pthread_self());
	return NULL;
}
int main()
{
	struct Test t;
	pthread_t tid;
	pthread_create(&tid, NULL, callback, &t);
	for (int i = 0; i < 5; i++)
	{
		printf("主线程:i=%d\n", i);
	}
	printf("主线程:%ld\n", pthread_self());
	void *ptr; // ptr指向&t
	pthread_join(tid, &ptr);
	printf("num=%d,age=%d\n", t.num, t.age);
	// pthread_join(tid,NULL);不接受子线程传出来的数据
}

```

## 线程分离

```c
#include<pthread.h>
//参数就子线程的线程ID，主线程就可以和这个子线程分离了
pthread_detach(pthread_t thread);
```

## 线程取消

```
#include<pthread.h>
//参数是要杀死的子线程的线程ID
int pthread_cancel(pthread_t thread);
```

## 线程ID的比较

```
#include<pthred.h>
int pthread_equal(pthread_t t1,pthread_t t2);
//参数t1和t2是要比较的线程的线程ID
//返回值：相等返回非0值，不等返回0
```

## 线程同步

### 同步

<font color=green>线程同步并不是多个线程同时对内存进行访问，而是按照先后顺序依次访问</font>

#### 同步的方式

多个线程访问共享资源就需要线程同步，四种方法：互斥锁，读写锁，条件变量，信号量

```c
//加锁
pthread_mutex_lock(&mutex);
//共享数据域
int cur=rand()%20;
number+=cur;//全局变量
if(number%2)
{
   printf("%d",number);
}
//解锁
pthread_mutex_unlock(&mutex);
```

### 互斥锁

​       创建的锁对象中保存了当前这把锁的状态信息：锁定还是打开，如果是锁定状态还记录了给这把锁加锁的线程信息（线程 ID）。一个互斥锁变量只能被一个线程锁定，被锁定之后其他线程再对互斥锁变量加锁就会被阻塞，直到这把互斥锁被解锁，被阻塞的线程才能被解除阻塞。一般情况下，每一个共享资源对应一个把互斥锁，锁的个数和线程的个数无关。

创建锁

```c
pthread_mutex_t mutex;
```



```c
/ 初始化互斥锁
// restrict: 是一个关键字, 用来修饰指针, 只有这个关键字修饰的指针可以访问指向的内存地址, 其他指针是不行的
int pthread_mutex_init(pthread_mutex_t *restrict mutex,
           const pthread_mutexattr_t *restrict attr);
// 释放互斥锁资源            
int pthread_mutex_destroy(pthread_mutex_t *mutex);


```

**参数:**
mutex: 互斥锁变量的地址
attr: 互斥锁的属性，一般使用默认属性即可，这个参数指定为 NULL

加锁

```
int pthread_mutex_lock(pthread_mutex_t *mutex);//给代码段加锁
```

线程会判断当前锁的状态：

如果是上锁状态：线程会阻塞在此处   

如果为未锁：线程加锁并记录锁状态，向下执行

尝试加锁

```c
// 尝试加锁
int pthread_mutex_trylock(pthread_mutex_t *mutex);
```

线程会判断当前锁的状态：

如果是上锁状态：线程不会被阻塞，加锁失败直接返回错误号
如果为未锁：线程加锁并记录锁状态，向下执行

解锁

```c
// 对互斥锁解锁
int pthread_mutex_unlock(pthread_mutex_t *mutex);
```

#### 使用互斥锁进行线程同步

```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <string.h>
#include <pthread.h>

#define MAX 50
// 全局变量
int number;

// 线程处理函数
void* funcA_num(void* arg)
{
    for(int i=0; i<MAX; ++i)
    {
        int cur = number;
        cur++;
        usleep(10);
        number = cur;
        printf("Thread A, id = %lu, number = %d\n", pthread_self(), number);
    }

    return NULL;
}

void* funcB_num(void* arg)
{
    for(int i=0; i<MAX; ++i)
    {
        int cur = number;
        cur++;
        number = cur;
        printf("Thread B, id = %lu, number = %d\n", pthread_self(), number);
        usleep(5);
    }

    return NULL;
}

int main(int argc, const char* argv[])
{
    pthread_t p1, p2;

    // 创建两个子线程
    pthread_create(&p1, NULL, funcA_num, NULL);
    pthread_create(&p2, NULL, funcB_num, NULL);

    // 阻塞，资源回收
    pthread_join(p1, NULL);
    pthread_join(p2, NULL);

    return 0;
}

/*
Thread B, id = 139740447761984, number = 1
Thread A, id = 139740456154688, number = 1
Thread B, id = 139740447761984, number = 2
Thread A, id = 139740456154688, number = 2
Thread B, id = 139740447761984, number = 3
Thread A, id = 139740456154688, number = 3
Thread B, id = 139740447761984, number = 4
Thread A, id = 139740456154688, number = 4
Thread B, id = 139740447761984, number = 5
Thread A, id = 139740456154688, number = 5
Thread A, id = 139740456154688, number = 6
Thread B, id = 139740447761984, number = 7
Thread A, id = 139740456154688, number = 7
Thread B, id = 139740447761984, number = 8
Thread B, id = 139740447761984, number = 9
Thread A, id = 139740456154688, number = 9
Thread B, id = 139740447761984, number = 10
Thread A, id = 139740456154688, number = 10
Thread B, id = 139740447761984, number = 11
Thread A, id = 139740456154688, number = 11
Thread B, id = 139740447761984, number = 12
Thread A, id = 139740456154688, number = 12
Thread B, id = 139740447761984, number = 13
Thread A, id = 139740456154688, number = 13
Thread B, id = 139740447761984, number = 14
Thread A, id = 139740456154688, number = 14
Thread B, id = 139740447761984, number = 15
Thread A, id = 139740456154688, number = 15
Thread B, id = 139740447761984, number = 16
Thread A, id = 139740456154688, number = 16
Thread B, id = 139740447761984, number = 17
Thread A, id = 139740456154688, number = 17
Thread B, id = 139740447761984, number = 18
Thread A, id = 139740456154688, number = 18
Thread B, id = 139740447761984, number = 19
Thread B, id = 139740447761984, number = 20
Thread A, id = 139740456154688, number = 19
Thread B, id = 139740447761984, number = 20
Thread A, id = 139740456154688, number = 20
Thread B, id = 139740447761984, number = 21
Thread A, id = 139740456154688, number = 21
Thread B, id = 139740447761984, number = 22
Thread A, id = 139740456154688, number = 22
Thread B, id = 139740447761984, number = 23
Thread A, id = 139740456154688, number = 23
Thread B, id = 139740447761984, number = 24
Thread A, id = 139740456154688, number = 24
Thread B, id = 139740447761984, number = 25
Thread A, id = 139740456154688, number = 25
Thread B, id = 139740447761984, number = 26
Thread A, id = 139740456154688, number = 26
Thread B, id = 139740447761984, number = 27
Thread A, id = 139740456154688, number = 27
Thread B, id = 139740447761984, number = 28
Thread A, id = 139740456154688, number = 28
Thread B, id = 139740447761984, number = 29
Thread A, id = 139740456154688, number = 29
Thread B, id = 139740447761984, number = 30
Thread B, id = 139740447761984, number = 31
Thread A, id = 139740456154688, number = 30
Thread B, id = 139740447761984, number = 31
Thread A, id = 139740456154688, number = 31
Thread B, id = 139740447761984, number = 32
Thread A, id = 139740456154688, number = 32
Thread B, id = 139740447761984, number = 33
Thread A, id = 139740456154688, number = 33
Thread B, id = 139740447761984, number = 34
Thread A, id = 139740456154688, number = 34
Thread B, id = 139740447761984, number = 35
Thread A, id = 139740456154688, number = 35
Thread B, id = 139740447761984, number = 36
Thread A, id = 139740456154688, number = 36
Thread B, id = 139740447761984, number = 37
Thread A, id = 139740456154688, number = 37
Thread B, id = 139740447761984, number = 38
Thread A, id = 139740456154688, number = 38
Thread B, id = 139740447761984, number = 39
Thread A, id = 139740456154688, number = 39
Thread B, id = 139740447761984, number = 40
Thread A, id = 139740456154688, number = 40
Thread B, id = 139740447761984, number = 41
Thread A, id = 139740456154688, number = 41
Thread B, id = 139740447761984, number = 42
Thread A, id = 139740456154688, number = 42
Thread B, id = 139740447761984, number = 43
Thread B, id = 139740447761984, number = 43
Thread A, id = 139740456154688, number = 43
Thread B, id = 139740447761984, number = 44
Thread A, id = 139740456154688, number = 44
Thread B, id = 139740447761984, number = 45
Thread A, id = 139740456154688, number = 45
Thread B, id = 139740447761984, number = 46
Thread A, id = 139740456154688, number = 46
Thread B, id = 139740447761984, number = 47
Thread A, id = 139740456154688, number = 47
Thread B, id = 139740447761984, number = 48
Thread A, id = 139740456154688, number = 48
Thread A, id = 139740456154688, number = 49
Thread A, id = 139740456154688, number = 50
Thread A, id = 139740456154688, number = 51
*/

```

```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <string.h>
#include <pthread.h>

#define MAX 50
// 全局变量
int number;
pthread_mutex_t mutex; // 定义一个互斥锁

// 线程处理函数
void *funcA_num(void *arg)
{
	for (int i = 0; i < MAX; ++i)
	{
		pthread_mutex_lock(&mutex);
		int cur = number;
		cur++;
		usleep(10);
		number = cur;
		printf("Thread A, id = %lu, number = %d\n", pthread_self(), number);
		pthread_mutex_unlock(&mutex);
	}

	return NULL;
}

void *funcB_num(void *arg)
{
	for (int i = 0; i < MAX; ++i)
	{
		pthread_mutex_lock(&mutex);
		int cur = number;
		cur++;
		number = cur;
		printf("Thread B, id = %lu, number = %d\n", pthread_self(), number);
		pthread_mutex_unlock(&mutex);
		usleep(5); // 线程休眠微秒
	}

	return NULL;
}

int main(int argc, const char *argv[])
{
	pthread_t p1, p2;
	pthread_mutex_init(&mutex, NULL);

	// 创建两个子线程
	pthread_create(&p1, NULL, funcA_num, NULL);
	pthread_create(&p2, NULL, funcB_num, NULL);

	// 阻塞，资源回收
	pthread_join(p1, NULL);
	pthread_join(p2, NULL);

	pthread_mutex_destroy(&mutex);

	return 0;
}
/*
Thread A, id = 140637047354944, number = 1
Thread A, id = 140637047354944, number = 2
Thread A, id = 140637047354944, number = 3
Thread A, id = 140637047354944, number = 4
Thread A, id = 140637047354944, number = 5
Thread A, id = 140637047354944, number = 6
Thread A, id = 140637047354944, number = 7
Thread A, id = 140637047354944, number = 8
Thread A, id = 140637047354944, number = 9
Thread A, id = 140637047354944, number = 10
Thread A, id = 140637047354944, number = 11
Thread A, id = 140637047354944, number = 12
Thread A, id = 140637047354944, number = 13
Thread A, id = 140637047354944, number = 14
Thread A, id = 140637047354944, number = 15
Thread A, id = 140637047354944, number = 16
Thread A, id = 140637047354944, number = 17
Thread A, id = 140637047354944, number = 18
Thread A, id = 140637047354944, number = 19
Thread A, id = 140637047354944, number = 20
Thread A, id = 140637047354944, number = 21
Thread A, id = 140637047354944, number = 22
Thread A, id = 140637047354944, number = 23
Thread A, id = 140637047354944, number = 24
Thread A, id = 140637047354944, number = 25
Thread A, id = 140637047354944, number = 26
Thread A, id = 140637047354944, number = 27
Thread A, id = 140637047354944, number = 28
Thread A, id = 140637047354944, number = 29
Thread A, id = 140637047354944, number = 30
Thread A, id = 140637047354944, number = 31
Thread A, id = 140637047354944, number = 32
Thread A, id = 140637047354944, number = 33
Thread A, id = 140637047354944, number = 34
Thread A, id = 140637047354944, number = 35
Thread A, id = 140637047354944, number = 36
Thread A, id = 140637047354944, number = 37
Thread A, id = 140637047354944, number = 38
Thread A, id = 140637047354944, number = 39
Thread A, id = 140637047354944, number = 40
Thread A, id = 140637047354944, number = 41
Thread A, id = 140637047354944, number = 42
Thread A, id = 140637047354944, number = 43
Thread A, id = 140637047354944, number = 44
Thread A, id = 140637047354944, number = 45
Thread A, id = 140637047354944, number = 46
Thread A, id = 140637047354944, number = 47
Thread A, id = 140637047354944, number = 48
Thread A, id = 140637047354944, number = 49
Thread A, id = 140637047354944, number = 50
Thread B, id = 140637038962240, number = 51
Thread B, id = 140637038962240, number = 52
Thread B, id = 140637038962240, number = 53
Thread B, id = 140637038962240, number = 54
Thread B, id = 140637038962240, number = 55
Thread B, id = 140637038962240, number = 56
Thread B, id = 140637038962240, number = 57
Thread B, id = 140637038962240, number = 58
Thread B, id = 140637038962240, number = 59
Thread B, id = 140637038962240, number = 60
Thread B, id = 140637038962240, number = 61
Thread B, id = 140637038962240, number = 62
Thread B, id = 140637038962240, number = 63
Thread B, id = 140637038962240, number = 64
Thread B, id = 140637038962240, number = 65
Thread B, id = 140637038962240, number = 66
Thread B, id = 140637038962240, number = 67
Thread B, id = 140637038962240, number = 68
Thread B, id = 140637038962240, number = 69
Thread B, id = 140637038962240, number = 70
Thread B, id = 140637038962240, number = 71
Thread B, id = 140637038962240, number = 72
Thread B, id = 140637038962240, number = 73
Thread B, id = 140637038962240, number = 74
Thread B, id = 140637038962240, number = 75
Thread B, id = 140637038962240, number = 76
Thread B, id = 140637038962240, number = 77
Thread B, id = 140637038962240, number = 78
Thread B, id = 140637038962240, number = 79
Thread B, id = 140637038962240, number = 80
Thread B, id = 140637038962240, number = 81
Thread B, id = 140637038962240, number = 82
Thread B, id = 140637038962240, number = 83
Thread B, id = 140637038962240, number = 84
Thread B, id = 140637038962240, number = 85
Thread B, id = 140637038962240, number = 86
Thread B, id = 140637038962240, number = 87
Thread B, id = 140637038962240, number = 88
Thread B, id = 140637038962240, number = 89
Thread B, id = 140637038962240, number = 90
Thread B, id = 140637038962240, number = 91
Thread B, id = 140637038962240, number = 92
Thread B, id = 140637038962240, number = 93
Thread B, id = 140637038962240, number = 94
Thread B, id = 140637038962240, number = 95
Thread B, id = 140637038962240, number = 96
Thread B, id = 140637038962240, number = 97
Thread B, id = 140637038962240, number = 98
Thread B, id = 140637038962240, number = 99
Thread B, id = 140637038962240, number = 100
抢cpu时机片是随机的，并不一定是交替进行
*/

```

###  死锁

了当多个线程访问共享资源，需要加锁，如果锁使用不当，就会造成死锁这种现象。如果线程死锁造成的后果是：所有的线程都被阻塞，并且线程的阻塞是无法解开的（因为可以解锁的线程也被阻塞了）

​      
